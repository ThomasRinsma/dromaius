#ifndef INCLUDED_MEMORY_H
#define INCLUDED_MEMORY_H

#include <cstddef>
#include <cstdint>
#include <string>
#include <map>
struct Dromaius;

#define MEMORY_MAX_SYMBOL_SIZE 100

struct Memory
{
	// Up-reference
	Dromaius *emu;

	// Hardcoded GameBoy bios
	static constexpr uint8_t bios[256] = {
		0x31, 0xFE, 0xFF, 0xAF, 0x21, 0xFF, 0x9F, 0x32, 0xCB, 0x7C, 0x20, 0xFB, 0x21, 0x26, 0xFF, 0x0E,
		0x11, 0x3E, 0x80, 0x32, 0xE2, 0x0C, 0x3E, 0xF3, 0xE2, 0x32, 0x3E, 0x77, 0x77, 0x3E, 0xFC, 0xE0,
		0x47, 0x11, 0x04, 0x01, 0x21, 0x10, 0x80, 0x1A, 0xCD, 0x95, 0x00, 0xCD, 0x96, 0x00, 0x13, 0x7B,
		0xFE, 0x34, 0x20, 0xF3, 0x11, 0xD8, 0x00, 0x06, 0x08, 0x1A, 0x13, 0x22, 0x23, 0x05, 0x20, 0xF9,
		0x3E, 0x19, 0xEA, 0x10, 0x99, 0x21, 0x2F, 0x99, 0x0E, 0x0C, 0x3D, 0x28, 0x08, 0x32, 0x0D, 0x20,
		0xF9, 0x2E, 0x0F, 0x18, 0xF3, 0x67, 0x3E, 0x64, 0x57, 0xE0, 0x42, 0x3E, 0x91, 0xE0, 0x40, 0x04,
		0x1E, 0x02, 0x0E, 0x0C, 0xF0, 0x44, 0xFE, 0x90, 0x20, 0xFA, 0x0D, 0x20, 0xF7, 0x1D, 0x20, 0xF2,
		0x0E, 0x13, 0x24, 0x7C, 0x1E, 0x83, 0xFE, 0x62, 0x28, 0x06, 0x1E, 0xC1, 0xFE, 0x64, 0x20, 0x06,
		0x7B, 0xE2, 0x0C, 0x3E, 0x87, 0xF2, 0xF0, 0x42, 0x90, 0xE0, 0x42, 0x15, 0x20, 0xD2, 0x05, 0x20,
		0x4F, 0x16, 0x20, 0x18, 0xCB, 0x4F, 0x06, 0x04, 0xC5, 0xCB, 0x11, 0x17, 0xC1, 0xCB, 0x11, 0x17,
		0x05, 0x20, 0xF5, 0x22, 0x23, 0x22, 0x23, 0xC9, 0xCE, 0xED, 0x66, 0x66, 0xCC, 0x0D, 0x00, 0x0B,
		0x03, 0x73, 0x00, 0x83, 0x00, 0x0C, 0x00, 0x0D, 0x00, 0x08, 0x11, 0x1F, 0x88, 0x89, 0x00, 0x0E,
		0xDC, 0xCC, 0x6E, 0xE6, 0xDD, 0xDD, 0xD9, 0x99, 0xBB, 0xBB, 0x67, 0x63, 0x6E, 0x0E, 0xEC, 0xCC,
		0xDD, 0xDC, 0x99, 0x9F, 0xBB, 0xB9, 0x33, 0x3E, 0x3c, 0x42, 0xB9, 0xA5, 0xB9, 0xA5, 0x42, 0x4C,
		0x21, 0x04, 0x01, 0x11, 0xA8, 0x00, 0x1A, 0x13, 0xBE, 0x20, 0xFE, 0x23, 0x7D, 0xFE, 0x34, 0x20,
		0xF5, 0x06, 0x19, 0x78, 0x86, 0x23, 0x05, 0x20, 0xFB, 0x86, 0x20, 0xFE, 0x3E, 0x01, 0xE0, 0x50
	};

	enum class MBC {
		NONE,
		MBC1,
		MBC2,
		MBC3,
		MBC4,
		MBC5,
		MMM01,
		OTHER,
	} mbc;

	inline std::string mbcAsString() {
		switch (mbc) {
			case MBC::NONE: return "NONE";
			case MBC::MBC1: return "MBC1";
			case MBC::MBC2: return "MBC2";
			case MBC::MBC3: return "MBC3";
			case MBC::MBC4: return "MBC4";
			case MBC::MBC5: return "MBC5";
			case MBC::MMM01: return "MMM01";
			case MBC::OTHER: return "OTHER";
			default: return "(invalid mbc)";
		}
	}

	typedef struct romheader_s {
		char	gamename[15];
		uint8_t	colorbyte;		// 0x80 = yes
		uint16_t newlicensee;
		uint8_t	sgbfeatures;	// 0x03 = yes
		uint8_t	type;
		uint8_t	romsize;
		uint8_t	ramsize;
		uint8_t	country;		// 0x00 = japan, 0x01 = other
		uint8_t	oldlicensee;
		uint8_t	headersum;
		uint16_t romsum;
	} romheader_t;

	// Dynamic buffer for ROM image
	uint8_t *rom;
	size_t romLen;
	size_t ramSize;

	uint8_t workram[0x2000]; // 8kb
	uint8_t extram[0x2000];
	uint8_t zeropageram[128];

	bool ramEnabled;
	uint8_t bankMode; // 0 = ROM, 1 = RAM
	uint8_t ramBank;
	uint8_t romBank;
	uint8_t rtcReg;
	uint8_t rtc[5];

	// Flags
	bool initialized = false;
	bool romLoaded = false;
	bool biosLoaded = true;

	// map<<pageNr, addr>, symbol>
	std::map<std::pair<uint8_t, uint16_t>, std::string> addrToSymbol;
	// map<symbol, <pageNr, addr>>
	std::map<std::string, std::pair<uint8_t, uint16_t>> symbolToAddr;

	~Memory();

	// TODO: operator[]() overload?
	uint8_t readByte(uint16_t addr);
	uint16_t readWord(uint16_t addr);

	void writeByte(uint8_t b, uint16_t addr);
	void writeWord(uint16_t w, uint16_t addr);

	std::string getRegionName(uint16_t addr);
	std::string getCartridgeTypeString(uint8_t type);
	std::string getCartridgeRomSizeString(uint8_t size);
	std::string getCartridgeRamSizeString(uint8_t size);
	


	void dumpToFile(std::string const &filename);
	void tryParseSymbolsFile(std::string filename);


	std::string getSymbolFromAddress(uint8_t bank, uint16_t addr);
	std::pair<uint8_t, uint16_t> getAddressFromSymbol(uint8_t bank, std::string &symbol);

	bool loadRom(std::string const &filename);
	void unloadRom();
	void initialize();
	void freeBuffers();

};

#endif